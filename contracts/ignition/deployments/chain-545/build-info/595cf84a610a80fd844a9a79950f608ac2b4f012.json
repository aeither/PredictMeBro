{
  "_format": "hh3-sol-build-info-1",
  "id": "595cf84a610a80fd844a9a79950f608ac2b4f012",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/EscrowPool.sol": "project/contracts/EscrowPool.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "viaIR": true,
      "optimizer": {
        "enabled": true,
        "runs": 200,
        "details": {
          "yulDetails": {
            "optimizerSteps": "u"
          }
        }
      },
      "evmVersion": "shanghai",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/EscrowPool.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract EscrowPool {\n    struct Pool {\n        string creatorName;\n        uint256 price;\n        uint256 poolPrize;\n        uint256 poolBalance;\n        uint256 startTime;\n        uint256 endTime;\n        bool isActive;\n        address creator;\n        string walrusHash;\n        bool isResolved;\n        bool winningVote;\n        uint256 totalWinners;\n        uint256 totalWinnerAmount;\n        uint256 claimedAmount;\n    }\n    \n    struct Participant {\n        address participant;\n        bool vote;\n        uint256 amount;\n        uint256 timestamp;\n        bool hasClaimed;\n    }\n    \n    mapping(uint256 => Pool) public pools;\n    mapping(uint256 => Participant[]) public poolParticipants;\n    mapping(uint256 => mapping(address => bool)) public hasVoted;\n    mapping(uint256 => mapping(address => uint256)) public participantIndex;\n    \n    uint256 public poolCounter;\n    uint256 public constant CREATOR_FEE_PERCENT = 5;\n    \n    event PoolCreated(\n        uint256 indexed poolId,\n        string creatorName,\n        uint256 price,\n        uint256 poolPrize,\n        uint256 startTime,\n        uint256 endTime,\n        address creator\n    );\n    \n    event VoteCast(\n        uint256 indexed poolId,\n        address indexed participant,\n        bool vote,\n        uint256 amount\n    );\n    \n    event PoolResolved(\n        uint256 indexed poolId,\n        bool winningVote,\n        uint256 totalWinners,\n        uint256 totalWinnerAmount\n    );\n    \n    event RewardClaimed(\n        uint256 indexed poolId,\n        address indexed participant,\n        uint256 amount\n    );\n    \n    modifier poolExists(uint256 poolId) {\n        require(poolId < poolCounter, \"Pool does not exist\");\n        _;\n    }\n    \n    modifier poolActive(uint256 poolId) {\n        require(pools[poolId].isActive, \"Pool is not active\");\n        require(block.timestamp >= pools[poolId].startTime, \"Pool has not started\");\n        require(block.timestamp <= pools[poolId].endTime, \"Pool has ended\");\n        _;\n    }\n    \n    modifier poolEnded(uint256 poolId) {\n        require(block.timestamp > pools[poolId].endTime, \"Pool has not ended yet\");\n        _;\n    }\n    \n    modifier hasNotVoted(uint256 poolId) {\n        require(!hasVoted[poolId][msg.sender], \"Already voted in this pool\");\n        _;\n    }\n    \n    modifier onlyCreator(uint256 poolId) {\n        require(msg.sender == pools[poolId].creator, \"Only pool creator can call this\");\n        _;\n    }\n    \n    function createPool(\n        string memory _creatorName,\n        uint256 _price,\n        uint256 _startTime,\n        uint256 _endTime,\n        string memory _walrusHash\n    ) external payable returns (uint256) {\n        require(_startTime < _endTime, \"Invalid time range\");\n        require(_startTime > block.timestamp, \"Start time must be in the future\");\n        require(msg.value > 0, \"Pool prize must be greater than 0\");\n        require(_price > 0, \"Participation price must be greater than 0\");\n        \n        uint256 poolId = poolCounter++;\n        \n        _createPoolData(poolId, _creatorName, _price, _startTime, _endTime, _walrusHash);\n        \n        emit PoolCreated(poolId, _creatorName, _price, msg.value, _startTime, _endTime, msg.sender);\n        \n        return poolId;\n    }\n    \n    function _createPoolData(\n        uint256 poolId,\n        string memory _creatorName,\n        uint256 _price,\n        uint256 _startTime,\n        uint256 _endTime,\n        string memory _walrusHash\n    ) internal {\n        pools[poolId] = Pool({\n            creatorName: _creatorName,\n            price: _price,\n            poolPrize: msg.value,\n            poolBalance: msg.value,\n            startTime: _startTime,\n            endTime: _endTime,\n            isActive: true,\n            creator: msg.sender,\n            walrusHash: _walrusHash,\n            isResolved: false,\n            winningVote: false,\n            totalWinners: 0,\n            totalWinnerAmount: 0,\n            claimedAmount: 0\n        });\n    }\n    \n    function vote(uint256 poolId, bool _vote) \n        external \n        payable \n        poolExists(poolId) \n        poolActive(poolId) \n        hasNotVoted(poolId) \n    {\n        require(msg.value >= pools[poolId].price, \"Insufficient payment\");\n        \n        _addParticipant(poolId, _vote);\n        \n        emit VoteCast(poolId, msg.sender, _vote, msg.value);\n    }\n    \n    function _addParticipant(uint256 poolId, bool _vote) internal {\n        participantIndex[poolId][msg.sender] = poolParticipants[poolId].length;\n        \n        poolParticipants[poolId].push(Participant({\n            participant: msg.sender,\n            vote: _vote,\n            amount: msg.value,\n            timestamp: block.timestamp,\n            hasClaimed: false\n        }));\n        \n        pools[poolId].poolBalance += msg.value;\n        hasVoted[poolId][msg.sender] = true;\n    }\n    \n    function resolvePool(uint256 poolId, bool _winningVote) \n        external \n        poolExists(poolId) \n        poolEnded(poolId) \n        onlyCreator(poolId) \n    {\n        require(!pools[poolId].isResolved, \"Pool already resolved\");\n        \n        pools[poolId].isResolved = true;\n        pools[poolId].winningVote = _winningVote;\n        \n        _calculateWinners(poolId, _winningVote);\n        \n        emit PoolResolved(poolId, _winningVote, pools[poolId].totalWinners, pools[poolId].totalWinnerAmount);\n    }\n    \n    function _calculateWinners(uint256 poolId, bool _winningVote) internal {\n        uint256 totalWinnerAmount = 0;\n        uint256 totalWinners = 0;\n        uint256 participantCount = poolParticipants[poolId].length;\n        \n        for (uint256 i = 0; i < participantCount; i++) {\n            if (poolParticipants[poolId][i].vote == _winningVote) {\n                totalWinners++;\n                totalWinnerAmount += poolParticipants[poolId][i].amount;\n            }\n        }\n        \n        pools[poolId].totalWinners = totalWinners;\n        pools[poolId].totalWinnerAmount = totalWinnerAmount;\n    }\n    \n    function claimReward(uint256 poolId) \n        external \n        poolExists(poolId) \n        poolEnded(poolId) \n    {\n        require(pools[poolId].isResolved, \"Pool not resolved yet\");\n        require(hasVoted[poolId][msg.sender], \"You didn't participate in this pool\");\n        \n        _processRewardClaim(poolId);\n    }\n    \n    function _processRewardClaim(uint256 poolId) internal {\n        uint256 participantIdx = participantIndex[poolId][msg.sender];\n        Participant storage participant = poolParticipants[poolId][participantIdx];\n        \n        require(participant.vote == pools[poolId].winningVote, \"You didn't vote for the winning side\");\n        require(!participant.hasClaimed, \"Reward already claimed\");\n        \n        uint256 participantReward = _calculateReward(poolId, participant.amount);\n        \n        participant.hasClaimed = true;\n        pools[poolId].claimedAmount += participantReward;\n        \n        payable(msg.sender).transfer(participantReward);\n        \n        emit RewardClaimed(poolId, msg.sender, participantReward);\n    }\n    \n    function _calculateReward(uint256 poolId, uint256 participantAmount) \n        internal \n        view \n        returns (uint256) \n    {\n        uint256 totalPoolBalance = pools[poolId].poolBalance;\n        uint256 creatorFee = (totalPoolBalance * CREATOR_FEE_PERCENT) / 100;\n        uint256 availableReward = totalPoolBalance - creatorFee;\n        \n        return (availableReward * participantAmount) / pools[poolId].totalWinnerAmount;\n    }\n    \n    function claimCreatorFee(uint256 poolId) \n        external \n        poolExists(poolId) \n        poolEnded(poolId) \n        onlyCreator(poolId) \n    {\n        require(pools[poolId].isResolved, \"Pool not resolved yet\");\n        \n        uint256 creatorFee = (pools[poolId].poolBalance * CREATOR_FEE_PERCENT) / 100;\n        \n        payable(pools[poolId].creator).transfer(creatorFee);\n        pools[poolId].poolBalance -= creatorFee;\n    }\n    \n    function getClaimableAmount(uint256 poolId, address participant) \n        public \n        view \n        poolExists(poolId) \n        returns (uint256) \n    {\n        if (!pools[poolId].isResolved || !hasVoted[poolId][participant]) {\n            return 0;\n        }\n        \n        return _getClaimableAmountInternal(poolId, participant);\n    }\n    \n    function _getClaimableAmountInternal(uint256 poolId, address participant) \n        internal \n        view \n        returns (uint256) \n    {\n        uint256 participantIdx = participantIndex[poolId][participant];\n        Participant memory participantData = poolParticipants[poolId][participantIdx];\n        \n        if (participantData.vote != pools[poolId].winningVote || participantData.hasClaimed) {\n            return 0;\n        }\n        \n        return _calculateReward(poolId, participantData.amount);\n    }\n    \n    function getPoolInfo(uint256 poolId, address participant) \n        external \n        view \n        poolExists(poolId) \n        returns (Pool memory, uint256 participantCount, uint256 claimableAmount, bool voted) \n    {\n        return (pools[poolId], poolParticipants[poolId].length, getClaimableAmount(poolId, participant), hasVoted[poolId][participant]);\n    }\n    \n    function getParticipantCount(uint256 poolId) \n        external \n        view \n        poolExists(poolId) \n        returns (uint256) \n    {\n        return poolParticipants[poolId].length;\n    }\n    \n    function getVoteCounts(uint256 poolId) \n        external \n        view \n        poolExists(poolId) \n        returns (uint256 yesVotes, uint256 noVotes) \n    {\n        return _countVotes(poolId);\n    }\n    \n    function _countVotes(uint256 poolId) \n        internal \n        view \n        returns (uint256 yesVotes, uint256 noVotes) \n    {\n        uint256 participantCount = poolParticipants[poolId].length;\n        \n        for (uint256 i = 0; i < participantCount; i++) {\n            if (poolParticipants[poolId][i].vote) {\n                yesVotes++;\n            } else {\n                noVotes++;\n            }\n        }\n    }\n    \n    function getTotalPools() external view returns (uint256) {\n        return poolCounter;\n    }\n    \n    function getPoolParticipants(uint256 poolId) \n        external \n        view \n        poolExists(poolId) \n        returns (Participant[] memory) \n    {\n        return poolParticipants[poolId];\n    }\n    \n    function getPoolWalrusHash(uint256 poolId) \n        external \n        view \n        poolExists(poolId) \n        returns (string memory) \n    {\n        return pools[poolId].walrusHash;\n    }\n}\n"
      }
    }
  }
}